name: repo-inventory-extraction
description: Extracts a standardized, compact repository inventory for large-scale GitLab to GitHub migration planning. Outputs one JSON per category.
triggers:
  - context:
      projects: {}
    manual: {}

action:
  limits:
    maxParallel: 10
    maxTotal: 100
  steps:
    - agent:
        prompt: |-
          You are a repository inventory extraction agent. You run inside a checked-out Git repository (root is current working directory). Your job is to output concise, machine-friendly JSON objects for a fixed set of categories. The execution engine will ask you one question per category and will store your JSON response in a CSV column.

          Rules:
          - Answer ONLY with the requested JSON object. No prose, no explanations, no markdown.
          - Return strictly valid JSON.
          - Use compact JSON with minimal keys.
          - Use deterministic ordering: sort arrays lexicographically by stable keys unless otherwise specified.
          - If unknown/not present, use null, empty string, empty array, or empty object as appropriate.
          - Never output secret values. If you detect secrets, only report counts/types/paths, never contents.
          - Derive answers by inspecting repo files and git history (e.g., .gitlab-ci.yml, Jenkinsfile, package manifests, build scripts, config, IaC, docs).
          - Paths should be repo-relative, using forward slashes.
          - Keep each JSON under ~2000 characters where possible; summarize with counts and top samples.
          - Dates must be ISO 8601 (YYYY-MM-DD or YYYY-MM-DDTHH:MM:SSZ if available).
          - When producing "top" lists, return at most five items.
    - report:
        outputs:
          - key: identity
            string: {}
            title: identity
            prompt: |-
              Extract identity and basic repository metadata as JSON with this schema (do not add keys):
              {
                "name": "",
                "default_branch": "",
                "archived_hint": false,
                "last_commit_date": "",
                "first_commit_date": "",
                "commit_count": 0,
                "size_mb_hint": null,
                "uses_lfs": false,
                "lfs_patterns": [],
                "submodules_present": false,
                "submodules": [],
                "applications": []
              }
              Notes:
              - archived_hint, uses_lfs, submodules_present are booleans.
              - commit_count is an integer (use 0 if unknown).
              - size_mb_hint is integer MB or null if unknown.
              - lfs_patterns is an array of glob strings.
              - submodules entries are objects: {"path":"","url":"","branch":""} using empty string when unknown.
              - applications is an array of detected applications in the repo. Each entry: {"name":"","description":""}.
                Detect applications by common indicators such as:
                - deployable units (Dockerfiles, Helm charts, k8s manifests, serverless configs)
                - build targets (package.json name, Maven artifactId, .NET csproj AssemblyName, Python packages/apps, Android/iOS app projects)
                - directories like apps/, services/, cmd/, src/ with distinct build manifests.
                For description, use the best short description from README/module docs near the app, or from manifest fields (description), else empty.
              FINAL INSTRUCTION
              Return ONLY the JSON object. No extra text.
          - key: ownership
            string: {}
            title: ownership
            prompt: |-
              Extract ownership and routing signals as JSON with this schema (do not add keys):
              {
                "codeowners_paths": [],
                "codeowners_top5": [],
                "maintainers": [],
                "top_committers_top5": []
              }
              Notes:
              - codeowners_paths: array of repo-relative paths.
              - codeowners_top5: array of up to 5 owner tokens (emails or @handles), ordered by frequency then lexicographic.
              - maintainers: array of emails/usernames from MAINTAINERS/OWNERS/metadata when present.
              - top_committers_top5: array of up to 5 objects {"email":"","commits":0}.
              FINAL INSTRUCTION
              Return ONLY the JSON object. No extra text.
          - key: stack
            string: {}
            title: stack
            prompt: |-
              Extract tech stack, build entrypoints, and stack maintainers as JSON with this schema (do not add keys):
              {
                "primary_languages_top5": [],
                "repo_type_tags": [],
                "frameworks_tools": [],
                "build_systems": [],
                "build_entrypoints": [],
                "monorepo_hint": false,
                "top_stack_maintainers_top5": []
              }
              Notes:
              - primary_languages_top5: array of up to 5 objects {"lang":"","loc":0}.
              - repo_type_tags values from {lib,service,webapp,mobile,desktop,cli,data,ml,infra,monorepo,docs,tooling}.
              - frameworks_tools/build_systems/build_entrypoints: arrays of strings, lexicographically sorted.
              - monorepo_hint is boolean.
              - top_stack_maintainers_top5: up to 5 objects {"email":"","commits":0}, derived by attributing commits to files that define/maintain the stack:
                include commits touching framework/build system config and entrypoints such as:
                package.json,yarn.lock,pnpm-lock.yaml,poetry.lock,pyproject.toml,requirements*.txt,pom.xml,build.gradle*,settings.gradle*,go.mod,go.sum,Cargo.toml,Cargo.lock,*.csproj,*.fsproj,*.sln,gradle.properties,Makefile,CMakeLists.txt,bazel WORKSPACE/BUILD files,nx.json,turbo.json,lerna.json, and similar.
                Use default-branch history and count commits per author email across these files; return top 5.
              FINAL INSTRUCTION
              Return ONLY the JSON object. No extra text.
          - key: ci
            string: {}
            title: ci
            prompt: |-
              Extract CI and pipeline fingerprint (including CI maintainers) as JSON with this schema (do not add keys):
              {
                "ci_systems": [],
                "gitlab": {
                  "present": false,
                  "includes": [],
                  "job_count": null,
                  "stages": [],
                  "runner_tags": [],
                  "images": [],
                  "services": [],
                  "artifacts": { "jobs_with_artifacts": null, "max_expire_in": "" },
                  "cache": { "uses_cache": false, "cache_keys": null }
                },
                "jenkins": {
                  "present": false,
                  "jenkinsfile_paths": [],
                  "type": "",
                  "agents": [],
                  "shared_libs": []
                },
                "github_actions": {
                  "present": false,
                  "workflow_count": null
                },
                "other_ci_configs": [],
                "top_ci_maintainers_top5": []
              }
              Notes:
              - present fields and uses_cache are booleans.
              - job_count, workflow_count, cache_keys, jobs_with_artifacts are integers or null.
              - artifacts.max_expire_in is a string (e.g., "1 week") or empty string.
              - jenkins.type is one of "declarative","scripted","unknown","".
              - top_ci_maintainers_top5: up to 5 objects {"email":"","commits":0}, derived by counting commits per author email on default-branch history that touched CI-related files such as:
                .gitlab-ci.yml, any included GitLab CI templates in-repo, Jenkinsfile(s), .github/workflows/*.yml, .circleci/config.yml, azure-pipelines.yml, buildkite pipeline files, teamcity settings, travis/bitrise configs, and any ci/ or .ci/ directories.
              FINAL INSTRUCTION
              Return ONLY the JSON object. No extra text.
          - key: execution
            string: {}
            title: execution
            prompt: |-
              Extract runner and execution constraints as JSON with this schema (do not add keys):
              {
                "requires_windows": false,
                "requires_macos": false,
                "requires_linux": false,
                "requires_gpu_hint": false,
                "docker_in_docker_hint": false,
                "network_dependencies_top30": []
              }
              Notes:
              - network_dependencies_top30: array of hostnames only (no credentials, no urls with paths), lexicographically sorted, max 30.
              FINAL INSTRUCTION
              Return ONLY the JSON object. No extra text.
          - key: dependencies
            string: {}
            title: dependencies
            prompt: |-
              Extract dependencies and coupling as JSON with this schema (do not add keys):
              {
                "subtree_or_vendor_deps_hint": false,
                "internal_deps": [],
                "git_dependencies": [],
                "artifact_publishers": [],
                "terraform_module_sources": [],
                "helm_charts": [],
                "upstream_repositories": [],
                "downstream_repositories": []
              }
              Notes:
              - internal_deps entries: {"type":"","id":"","scope":"","file":""} with type in {npm,maven,pypi,nuget,go,cargo,docker,git,terraform,helm,other} and scope in {runtime,build,ci}.
              - git_dependencies entries: {"url":"","ref":"","path":"","file":""} (use empty string when unknown).
              - artifact_publishers entries: {"type":"","name":"","registry":"","file":""}
              - terraform_module_sources entries: {"source":"","path":""}
              - helm_charts entries: {"chart_path":"","name":""}
              - upstream_repositories: repositories this repo depends on, best-effort, as array of objects:
                {"id":"","how":"manifest|git|ci|iac|doc","evidence_file":""}
                Where id is a repo-like identifier or git URL or internal repo path inferred from internal_deps/git_dependencies/terraform module sources/CI includes/docs.
              - downstream_repositories: repositories that depend on this repo, best-effort, as array of objects:
                {"id":"","how":"doc|badge|publish|ci_trigger","evidence_file":""}
                Only include if explicitly discoverable within this repo (e.g., README lists consumers, badges/links, publish docs that name consuming repos, CI triggers targeting other repos).
                If not discoverable, return empty array.
              FINAL INSTRUCTION
              Return ONLY the JSON object. No extra text.
          - key: release_deploy
            string: {}
            title: release_deploy
            prompt: |-
              Extract release and deployment signals (including released artifacts) as JSON with this schema (do not add keys):
              {
                "release_tag_pattern_hint": "",
                "has_changelog": false,
                "deployment_targets": [],
                "environments": [],
                "approvals": { "manual_gates": false, "approval_keywords_top20": [] },
                "artifacts": []
              }
              Notes:
              - deployment_targets values from {kubernetes,helm,argo,flux,terraform,ansible,serverless,vm,mobile_store,desktop_release,none}.
              - environments: array of environment names, lexicographically sorted.
              - approval_keywords_top20: array of tokens/keywords found, max 20.
              - artifacts: list all artifacts released/published from this repo, best-effort. Each entry:
                {"type":"","name":"","destination":"","evidence_file":""}
                type examples: npm,maven,nuget,pypi,docker,helm,terraform_module,github_release,mobile_store,desktop_installer,other
                destination examples: registry host/path, repository, bucket, store name, or empty if unknown.
                Infer from publish steps in CI, build configs, release tooling, and docs.
              FINAL INSTRUCTION
              Return ONLY the JSON object. No extra text.
          - key: quality_security
            string: {}
            title: quality_security
            prompt: |-
              Extract tests, quality gates, and security tooling as JSON with this schema (do not add keys):
              {
                "test_tools": [],
                "coverage_tools": [],
                "lint_format_tools": [],
                "security_tools": [],
                "supply_chain": { "sbom": false, "signing": false, "tools": [] }
              }
              Notes:
              - arrays are lexicographically sorted.
              FINAL INSTRUCTION
              Return ONLY the JSON object. No extra text.
          - key: secrets_compliance
            string: {}
            title: secrets_compliance
            prompt: |-
              Extract secrets and compliance metadata as JSON with this schema (do not add keys):
              {
                "secrets_references_top30": [],
                "secret_scanner_findings": { "findings": null, "types": [], "paths_top5": [] },
                "compliance_flags": []
              }
              Notes:
              - secrets_references_top30: array of secret reference identifiers (variable names, vault keys) without values, max 30.
              - secret_scanner_findings.findings is integer or null.
              - secret_scanner_findings.types: array of finding type labels, sorted.
              - secret_scanner_findings.paths_top5: array of up to 5 repo-relative paths.
              - compliance_flags values from {pii,phi,pci,gdpr,export,sox,none}; if none detected, return ["none"].
              FINAL INSTRUCTION
              Return ONLY the JSON object. No extra text.
          - key: governance_integrations
            string: {}
            title: governance_integrations
            prompt: |-
              Extract governance and integration signals as JSON with this schema (do not add keys):
              {
                "protected_branch_hint": false,
                "merge_strategy_hint": "",
                "required_reviewers": { "codeowners": false, "min_approvals": null },
                "gitlab_url_references_count": null,
                "external_integrations": [],
                "webhooks_hint": false
              }
              Notes:
              - merge_strategy_hint is one of "merge","squash","rebase","unknown","".
              - required_reviewers.min_approvals and gitlab_url_references_count are integers or null.
              - external_integrations values from {jira,servicenow,slack,teams,pagerduty,datadog,splunk,sonarqube,artifactory,nexus,vault}, sorted.
              FINAL INSTRUCTION
              Return ONLY the JSON object. No extra text.
          - key: planning
            string: {}
            title: planning
            prompt: |-
              Produce migration planning outputs as JSON with this schema (do not add keys):
              {
                "complexity_score_0_100": null,
                "migration_lane": "",
                "readiness_blockers": [],
                "owner_migration_brief_280c": ""
              }
              Notes:
              - complexity_score_0_100 is integer 0 to 100, or null.
              - migration_lane is one of "A_simple","B_standard","C_custom","D_regulated","".
              - readiness_blockers values from {no_owner,unknown_ci,custom_runner,secrets_migration,compliance_review,heavy_deps,submodules,large_lfs,stale_repo,none}; if none, return ["none"].
              - owner_migration_brief_280c is one line, max 280 chars, no newlines.
              FINAL INSTRUCTION
              Return ONLY the JSON object. No extra text.